<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Serial Console</title>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <style>
    :root {
      --bg: #1a1a2e;
      --terminal-bg: #0d0d1a;
      --text: #00ff88;
      --text-dim: #00cc6a;
      --accent: #00b4d8;
      --border: #2a2a4a;
      --toolbar-bg: #16213e;
      --button-bg: #0f3460;
      --button-hover: #1a4a7a;
      --danger: #e74c3c;
      --danger-hover: #c0392b;
      --scrollbar: #2a2a4a;
      --scrollbar-thumb: #00ff8844;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: #e0e0e0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      background: var(--toolbar-bg);
      border-bottom: 1px solid var(--border);
      padding: 10px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-shrink: 0;
    }

    header h1 {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--accent);
      letter-spacing: 0.5px;
    }

    header h1 span {
      color: var(--text);
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .toolbar label {
      font-size: 0.75rem;
      color: #8892b0;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .toolbar select, .toolbar input[type="number"] {
      background: var(--terminal-bg);
      color: #e0e0e0;
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 0.8rem;
      outline: none;
    }

    .toolbar select:focus, .toolbar input[type="number"]:focus {
      border-color: var(--accent);
    }

    .toolbar input[type="number"] {
      width: 80px;
    }

    button {
      background: var(--button-bg);
      color: #e0e0e0;
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 6px 14px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    button:hover {
      background: var(--button-hover);
      border-color: var(--accent);
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    button.connect {
      background: #0a3d2a;
      border-color: #00ff8844;
      color: var(--text);
    }

    button.connect:hover:not(:disabled) {
      background: #0d5a3a;
    }

    button.disconnect {
      background: #3d0a0a;
      border-color: #e74c3c44;
      color: var(--danger);
    }

    button.disconnect:hover:not(:disabled) {
      background: #5a1a1a;
    }

    .status-bar {
      background: var(--toolbar-bg);
      border-bottom: 1px solid var(--border);
      padding: 4px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 0.75rem;
      color: #8892b0;
      flex-shrink: 0;
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--danger);
      margin-right: 4px;
    }

    .status-indicator.connected {
      background: var(--text);
      box-shadow: 0 0 6px var(--text);
    }

    #terminal-container {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    #terminal {
      width: 100%;
      height: 100%;
      overflow-y: auto;
      padding: 12px 16px;
      font-family: 'Cascadia Code', 'Fira Code', 'JetBrains Mono', 'Consolas', 'Monaco', monospace;
      font-size: 14px;
      line-height: 1.5;
      color: var(--text);
      background: var(--terminal-bg);
      white-space: pre-wrap;
      word-break: break-all;
      cursor: text;
    }

    #terminal::-webkit-scrollbar {
      width: 8px;
    }

    #terminal::-webkit-scrollbar-track {
      background: var(--terminal-bg);
    }

    #terminal::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: 4px;
    }

    #terminal .system-msg {
      color: var(--accent);
    }

    #terminal .error-msg {
      color: var(--danger);
    }

    #terminal .sent-msg {
      color: #ffd700;
    }

    .input-bar {
      display: flex;
      align-items: center;
      background: var(--toolbar-bg);
      border-top: 1px solid var(--border);
      padding: 8px 16px;
      gap: 8px;
      flex-shrink: 0;
    }

    .input-bar input[type="text"] {
      flex: 1;
      background: var(--terminal-bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 8px 12px;
      font-family: 'Cascadia Code', 'Fira Code', monospace;
      font-size: 0.9rem;
      outline: none;
    }

    .input-bar input[type="text"]:focus {
      border-color: var(--accent);
    }

    .input-bar input[type="text"]::placeholder {
      color: #4a4a6a;
    }

    .line-ending-select {
      font-size: 0.75rem;
    }

    .checkbox-label {
      font-size: 0.75rem;
      color: #8892b0;
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      user-select: none;
    }

    .checkbox-label input {
      accent-color: var(--accent);
    }

    footer {
      background: var(--toolbar-bg);
      border-top: 1px solid var(--border);
      padding: 4px 20px;
      font-size: 0.7rem;
      color: #4a4a6a;
      text-align: center;
      flex-shrink: 0;
    }

    footer a {
      color: var(--accent);
      text-decoration: none;
    }

    .remote-bar {
      background: var(--toolbar-bg);
      border-bottom: 1px solid var(--border);
      padding: 6px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 0.8rem;
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    .remote-bar input[type="text"] {
      background: var(--terminal-bg);
      color: var(--accent);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 8px;
      font-family: 'Cascadia Code', monospace;
      font-size: 0.85rem;
      width: 100px;
      outline: none;
      letter-spacing: 2px;
      text-align: center;
    }

    .remote-bar input[type="text"]:focus {
      border-color: var(--accent);
    }

    .room-id-display {
      background: var(--terminal-bg);
      color: var(--accent);
      border: 1px solid var(--accent);
      border-radius: 4px;
      padding: 4px 10px;
      font-family: 'Cascadia Code', monospace;
      font-size: 0.95rem;
      letter-spacing: 3px;
      user-select: all;
      cursor: pointer;
    }

    .remote-bar .separator {
      color: var(--border);
      font-size: 1.2rem;
    }

    .peer-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: #0a3d2a;
      border: 1px solid #00ff8844;
      border-radius: 12px;
      padding: 2px 10px;
      font-size: 0.7rem;
      color: var(--text);
    }

    .peer-badge.remote-peer {
      background: #1a1a4a;
      border-color: var(--accent);
      color: var(--accent);
    }

    .peer-badge.clickable {
      cursor: pointer;
      transition: background 0.15s;
    }

    .peer-badge.clickable:hover {
      background: #0d5a3a;
    }

    .peer-list-panel {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      background: var(--toolbar-bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      min-width: 320px;
      max-width: 420px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 4px 16px rgba(0,0,0,0.4);
      font-size: 0.75rem;
    }

    .peer-list-panel.visible {
      display: block;
    }

    .peer-list-header {
      padding: 8px 12px;
      font-weight: 600;
      color: var(--accent);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .peer-list-item {
      padding: 6px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .peer-list-item:last-child {
      border-bottom: none;
    }

    .peer-list-item .peer-ip {
      color: var(--text);
      font-family: 'Cascadia Code', monospace;
      font-size: 0.8rem;
    }

    .peer-list-item .peer-id {
      color: #8892b0;
      font-size: 0.65rem;
      font-family: monospace;
    }

    .peer-list-item .peer-duration {
      color: #8892b0;
      font-size: 0.65rem;
      margin-left: auto;
    }

    .peer-list-item .peer-perm {
      font-size: 0.6rem;
      padding: 1px 6px;
      border-radius: 8px;
    }

    .peer-list-item .peer-perm.rw {
      background: #0a3d2a;
      color: var(--text);
      cursor: pointer;
      border: 1px solid #00ff8844;
    }

    .peer-list-item .peer-perm.rw:hover {
      background: #0d5a3a;
    }

    .peer-list-item .peer-perm.ro {
      background: #3d2a0a;
      color: #ffd700;
      cursor: pointer;
      border: 1px solid #ffd70044;
    }

    .peer-list-item .peer-perm.ro:hover {
      background: #5a3d0a;
    }

    .peer-list-empty {
      padding: 12px;
      text-align: center;
      color: #4a4a6a;
    }

    .pending-bar {
      background: #2a1a00;
      border-bottom: 1px solid #ffd70044;
      padding: 0;
      flex-shrink: 0;
      overflow: hidden;
      max-height: 0;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }

    .pending-bar.has-pending {
      max-height: 300px;
      padding: 6px 20px;
    }

    .pending-request {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 4px 0;
      font-size: 0.8rem;
      color: #ffd700;
    }

    .pending-request .pending-info {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pending-request .pending-name {
      color: var(--accent);
      font-weight: 600;
    }

    .pending-request .pending-ip {
      color: #8892b0;
      font-family: 'Cascadia Code', monospace;
      font-size: 0.75rem;
    }

    .pending-request button.accept-btn {
      background: #0a3d2a;
      border-color: #00ff8844;
      color: var(--text);
      padding: 3px 10px;
      font-size: 0.7rem;
    }

    .pending-request button.accept-btn:hover {
      background: #0d5a3a;
    }

    .pending-request button.reject-btn {
      background: #3d0a0a;
      border-color: #e74c3c44;
      color: var(--danger);
      padding: 3px 10px;
      font-size: 0.7rem;
    }

    .pending-request button.reject-btn:hover {
      background: #5a1a1a;
    }

    .permission-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.7rem;
      padding: 2px 8px;
      border-radius: 12px;
      border: 1px solid;
    }

    .permission-badge.read-write {
      background: #0a3d2a;
      border-color: #00ff8844;
      color: var(--text);
    }

    .permission-badge.view-only {
      background: #3d2a0a;
      border-color: #ffd70044;
      color: #ffd700;
    }

    #terminal .remote-msg {
      color: #bb86fc;
    }


    @media (max-width: 768px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
        padding: 8px 12px;
      }
      .toolbar {
        width: 100%;
      }
      .remote-bar {
        padding: 6px 12px;
        gap: 8px;
      }
      .status-bar {
        padding: 4px 12px;
        gap: 8px;
        flex-wrap: wrap;
      }
      .input-bar {
        padding: 6px 8px;
        gap: 4px;
        flex-wrap: wrap;
      }
      .input-bar input[type="text"] {
        font-size: 16px; /* prevents iOS zoom on focus */
        padding: 10px 12px;
      }
      #terminal {
        font-size: 12px;
        padding: 8px 10px;
        line-height: 1.4;
        -webkit-overflow-scrolling: touch;
      }
      button {
        padding: 8px 12px;
        min-height: 36px;
        font-size: 0.8rem;
      }
      footer {
        padding: 4px 12px;
      }
    }

    /* Peer-mode mobile: hide host controls, maximize terminal */
    body.peer-mode header {
      padding: 4px 12px;
    }

    body.peer-mode .toolbar {
      display: none;
    }

    body.peer-mode .remote-bar {
      padding: 4px 12px;
    }

    body.peer-mode .remote-bar #shareBtn,
    body.peer-mode .remote-bar .separator,
    body.peer-mode .remote-bar #peerNameInput,
    body.peer-mode .remote-bar #joinRoomInput,
    body.peer-mode .remote-bar #joinBtn {
      display: none;
    }

    @media (max-width: 768px) {
      body.peer-mode header h1 {
        font-size: 0.9rem;
      }
      body.peer-mode .status-bar {
        font-size: 0.65rem;
        padding: 2px 12px;
      }
      body.peer-mode .input-bar {
        flex-wrap: nowrap;
      }
      body.peer-mode .line-ending-select {
        display: none;
      }
      body.peer-mode footer {
        display: none;
      }
    }
  </style>
</head>
<body>

  <header>
    <h1><span>&gt;_</span> Serial Console</h1>
    <div class="toolbar">
      <label>Baud:
        <select id="baudRate">
          <option value="300">300</option>
          <option value="1200">1200</option>
          <option value="2400">2400</option>
          <option value="4800">4800</option>
          <option value="9600">9600</option>
          <option value="19200">19200</option>
          <option value="38400">38400</option>
          <option value="57600">57600</option>
          <option value="115200" selected>115200</option>
          <option value="230400">230400</option>
          <option value="460800">460800</option>
          <option value="921600">921600</option>
        </select>
      </label>
      <label>Data Bits:
        <select id="dataBits">
          <option value="7">7</option>
          <option value="8" selected>8</option>
        </select>
      </label>
      <label>Stop Bits:
        <select id="stopBits">
          <option value="1" selected>1</option>
          <option value="2">2</option>
        </select>
      </label>
      <label>Parity:
        <select id="parity">
          <option value="none" selected>None</option>
          <option value="even">Even</option>
          <option value="odd">Odd</option>
        </select>
      </label>
      <label>Flow:
        <select id="flowControl">
          <option value="none" selected>None</option>
          <option value="hardware">Hardware</option>
        </select>
      </label>
      <button id="connectBtn" class="connect" onclick="toggleConnection()">
        &#9654; Connect
      </button>
      <button onclick="clearTerminal()">Clear</button>
    </div>
  </header>

  <div class="status-bar">
    <span><span class="status-indicator" id="statusDot"></span> <span id="statusText">Disconnected</span></span>
    <span id="portInfo">No port selected</span>
    <span>RX: <span id="rxCount">0</span> bytes</span>
    <span>TX: <span id="txCount">0</span> bytes</span>
  </div>

  <div class="remote-bar" id="remoteBar">
    <button id="shareBtn" onclick="startSharing()">&#128279; Share Session</button>
    <span id="roomIdContainer" style="display:none;">
      Room: <span class="room-id-display" id="roomIdDisplay" title="Click to copy" onclick="copyRoomId()"></span>
      <button onclick="copyRoomId()" style="padding:3px 8px;font-size:0.7rem;">Copy</button>
      <button onclick="stopSharing()" class="disconnect" style="padding:3px 8px;font-size:0.7rem;">Stop</button>
    </span>
    <label class="checkbox-label" id="allowInputLabel" style="display:none;">
      <input type="checkbox" id="allowRemoteInput" onchange="updatePeerPermissions()"> Allow Remote Input
    </label>
    <span style="position:relative;display:inline-flex;align-items:center;">
      <span id="peerCount" style="display:none;" class="peer-badge clickable" onclick="togglePeerList()">0 peers</span>
      <div id="peerListPanel" class="peer-list-panel">
        <div class="peer-list-header">
          <span>Connected Peers</span>
          <span id="peerListClose" style="cursor:pointer;color:#8892b0;" onclick="togglePeerList()">&times;</span>
        </div>
        <div id="peerListBody"></div>
      </div>
    </span>
    <span class="separator">|</span>
    <input type="text" id="peerNameInput" placeholder="Your Name" maxlength="20" style="width:110px;background:var(--terminal-bg);color:#e0e0e0;border:1px solid var(--border);border-radius:4px;padding:4px 8px;font-size:0.8rem;outline:none;">
    <input type="text" id="joinRoomInput" placeholder="Room ID" maxlength="6" style="text-transform:uppercase;">
    <button id="joinBtn" onclick="joinSession()">Join Session</button>
    <span id="peerStatus" style="display:none;" class="peer-badge remote-peer">Connected to host</span>
    <span id="permissionStatus" style="display:none;" class="permission-badge view-only">View Only</span>
    <button id="leaveBtn" style="display:none;padding:3px 8px;font-size:0.7rem;" class="disconnect" onclick="disconnectPeer()">Leave</button>
  </div>

  <div id="pendingBar" class="pending-bar">
    <div id="pendingList"></div>
  </div>

  <div id="terminal-container">
    <div id="terminal" tabindex="0"></div>
  </div>

  <div class="input-bar">
    <input type="text" id="sendInput" placeholder="Type command and press Enter..." disabled>
    <label class="line-ending-select">
      <select id="lineEnding">
        <option value="\r\n">CR+LF</option>
        <option value="\r">CR</option>
        <option value="\n" selected>LF</option>
        <option value="">None</option>
      </select>
    </label>
    <label class="checkbox-label">
      <input type="checkbox" id="echoLocal"> Local Echo
    </label>
    <label class="checkbox-label">
      <input type="checkbox" id="autoScroll" checked> Auto-scroll
    </label>
    <button id="sendBtn" disabled onclick="handleSend()">Send</button>
  </div>

  <footer>
    Web Serial API &mdash; requires Chrome/Edge 89+ &middot; <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Serial_API" target="_blank">MDN Docs</a>
  </footer>

  <script>
    let port = null;
    let reader = null;
    let writer = null;
    let isConnected = false;
    let rxBytes = 0;
    let txBytes = 0;
    let keepReading = false;

    const terminal = document.getElementById('terminal');
    const connectBtn = document.getElementById('connectBtn');
    const sendInputEl = document.getElementById('sendInput');
    const sendBtn = document.getElementById('sendBtn');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const portInfo = document.getElementById('portInfo');
    const rxCountEl = document.getElementById('rxCount');
    const txCountEl = document.getElementById('txCount');

    function appendToTerminal(text, className) {
      const span = document.createElement('span');
      if (className) span.className = className;
      span.textContent = text;
      terminal.appendChild(span);
      if (document.getElementById('autoScroll').checked) {
        terminal.scrollTop = terminal.scrollHeight;
      }
    }

    function clearTerminal() {
      terminal.innerHTML = '';
      appendToTerminal('[Terminal cleared]\n', 'system-msg');
    }

    function updateStatus(connected, info) {
      isConnected = connected;
      statusDot.className = 'status-indicator' + (connected ? ' connected' : '');
      statusText.textContent = connected ? 'Connected' : 'Disconnected';
      portInfo.textContent = info || 'No port selected';
      connectBtn.innerHTML = connected ? '&#9632; Disconnect' : '&#9654; Connect';
      connectBtn.className = connected ? 'disconnect' : 'connect';
      sendInputEl.disabled = !connected;
      sendBtn.disabled = !connected;
      if (connected) sendInputEl.focus();
    }

    async function toggleConnection() {
      if (isConnected) {
        await disconnect();
      } else {
        await connect();
      }
    }

    async function connect() {
      if (!('serial' in navigator)) {
        appendToTerminal('[Error] Web Serial API not supported. Use Chrome or Edge 89+.\n', 'error-msg');
        return;
      }

      try {
        port = await navigator.serial.requestPort();
        const baudRate = parseInt(document.getElementById('baudRate').value);
        const dataBits = parseInt(document.getElementById('dataBits').value);
        const stopBits = parseInt(document.getElementById('stopBits').value);
        const parity = document.getElementById('parity').value;
        const flowControl = document.getElementById('flowControl').value;

        await port.open({ baudRate, dataBits, stopBits, parity, flowControl });

        const info = port.getInfo();
        const vendorId = info.usbVendorId ? `VID:0x${info.usbVendorId.toString(16).toUpperCase()}` : '';
        const productId = info.usbProductId ? `PID:0x${info.usbProductId.toString(16).toUpperCase()}` : '';
        const portDesc = [vendorId, productId].filter(Boolean).join(' ') || 'Serial Port';

        updateStatus(true, `${portDesc} @ ${baudRate} baud`);
        appendToTerminal(`[Connected] ${portDesc} | ${baudRate} ${dataBits}${parity[0].toUpperCase()}${stopBits} | Flow: ${flowControl}\n`, 'system-msg');

        keepReading = true;
        readLoop();

      } catch (err) {
        if (err.name === 'NotFoundError') {
          appendToTerminal('[Info] No port selected.\n', 'system-msg');
        } else {
          appendToTerminal(`[Error] ${err.message}\n`, 'error-msg');
        }
      }
    }

    async function readLoop() {
      const decoder = new TextDecoderStream();
      const readableStreamClosed = port.readable.pipeTo(decoder.writable);
      reader = decoder.readable.getReader();

      try {
        while (keepReading) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            rxBytes += new Blob([value]).size;
            rxCountEl.textContent = rxBytes;
            appendToTerminal(value);
          }
        }
      } catch (err) {
        if (keepReading) {
          appendToTerminal(`\n[Error] Read failed: ${err.message}\n`, 'error-msg');
        }
      } finally {
        reader.releaseLock();
        try { await readableStreamClosed; } catch {}
      }
    }

    async function disconnect() {
      keepReading = false;
      try {
        if (reader) {
          await reader.cancel();
          reader = null;
        }
        if (port) {
          await port.close();
          port = null;
        }
      } catch (err) {
        appendToTerminal(`[Error] Disconnect: ${err.message}\n`, 'error-msg');
      }
      updateStatus(false);
      appendToTerminal('[Disconnected]\n', 'system-msg');
    }

    async function sendData(text) {
      if (!port || !port.writable) return;
      const encoder = new TextEncoder();
      const writer = port.writable.getWriter();
      try {
        const data = encoder.encode(text);
        await writer.write(data);
        txBytes += data.length;
        txCountEl.textContent = txBytes;
        if (document.getElementById('echoLocal').checked) {
          appendToTerminal(text, 'sent-msg');
        }
      } finally {
        writer.releaseLock();
      }
    }

    function handleSend() {
      const text = sendInputEl.value;
      if (!text && !document.getElementById('lineEnding').value) return;

      const lineEnding = document.getElementById('lineEnding').value
        .replace('\\r', '\r')
        .replace('\\n', '\n');

      sendData(text + lineEnding);
      sendInputEl.value = '';
      sendInputEl.focus();
    }

    // Keyboard handling
    sendInputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        handleSend();
      }
    });

    // Direct keyboard input to terminal when focused
    terminal.addEventListener('keydown', (e) => {
      if (!isConnected) return;
      if (e.ctrlKey || e.altKey || e.metaKey) return;
      if (e.key.length === 1) {
        sendData(e.key);
        e.preventDefault();
      } else if (e.key === 'Enter') {
        const lineEnding = document.getElementById('lineEnding').value
          .replace('\\r', '\r')
          .replace('\\n', '\n');
        sendData(lineEnding);
        e.preventDefault();
      } else if (e.key === 'Backspace') {
        sendData('\b');
        e.preventDefault();
      }
    });

    // Handle port disconnect events
    navigator.serial?.addEventListener('disconnect', (e) => {
      if (port && e.target === port) {
        keepReading = false;
        updateStatus(false);
        appendToTerminal('\n[Port disconnected]\n', 'error-msg');
      }
    });

    // =============================================
    // WebRTC P2P Remote Sharing (PeerJS)
    // =============================================

    const PEER_CONFIG = {
      debug: 2,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
          { urls: 'stun:stun3.l.google.com:19302' },
          { urls: 'stun:stun4.l.google.com:19302' }
        ],
        // Expose real local IPs instead of mDNS (.local) hostnames
        // Critical for cross-VLAN / same-network connections
        sdpSemantics: 'unified-plan'
      }
    };

    // Detect if we're likely on the same local network as the peer
    // by comparing the first 3 octets of gathered host candidates
    let localIPs = [];

    async function gatherLocalIPs() {
      try {
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel('');
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        return new Promise((resolve) => {
          const ips = [];
          const timeout = setTimeout(() => { pc.close(); resolve(ips); }, 3000);
          pc.onicecandidate = (e) => {
            if (!e.candidate) { clearTimeout(timeout); pc.close(); resolve(ips); return; }
            const match = e.candidate.candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
            if (match && !match[1].startsWith('0.')) ips.push(match[1]);
          };
        });
      } catch { return []; }
    }

    gatherLocalIPs().then(ips => {
      localIPs = ips;
      if (ips.length > 0) {
        console.log('[ICE] Local IPs discovered:', ips);
      }
    });

    let peer = null;               // PeerJS instance
    let hostConnections = [];      // Host: array of DataConnections to peers
    let peerInfoMap = new Map();   // Map<DataConnection, {id, ip, connectedAt, candidates}>
    let pendingConnections = [];   // Host: connections awaiting approval {conn, id, name, ip}
    let peerConnection = null;     // Peer: DataConnection to host
    let isHost = false;
    let isPeer = false;
    let terminalHistory = '';      // Buffer of all terminal output for new peers
    let canWrite = false;          // Peer: whether host allows input
    let peerName = '';             // Peer: friendly display name
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    let currentRoomId = null;      // Track active room ID for reconnect
    const MAX_RECONNECT = 10;
    const BASE_DELAY = 1000;       // 1s base, doubles each attempt (max ~17 min)

    // =============================================
    // Session Persistence (sessionStorage)
    // =============================================

    function saveSession() {
      try {
        sessionStorage.setItem('sc_session', JSON.stringify({
          role: isHost ? 'host' : (isPeer ? 'peer' : null),
          roomId: currentRoomId,
          terminalHistory: terminalHistory.slice(-50000), // cap at 50KB for storage
          allowInput: isHost ? document.getElementById('allowRemoteInput').checked : canWrite,
          peerName: peerName || '',
          timestamp: Date.now()
        }));
      } catch {}
    }

    function loadSession() {
      try {
        const raw = sessionStorage.getItem('sc_session');
        if (!raw) return null;
        const session = JSON.parse(raw);
        // Expire after 30 minutes
        if (Date.now() - session.timestamp > 30 * 60 * 1000) {
          sessionStorage.removeItem('sc_session');
          return null;
        }
        return session;
      } catch { return null; }
    }

    function clearSession() {
      try { sessionStorage.removeItem('sc_session'); } catch {}
    }

    // Auto-save session state periodically
    setInterval(() => {
      if (isHost || isPeer) saveSession();
    }, 5000);

    // Save before unload (refresh/close)
    window.addEventListener('beforeunload', () => {
      if (isHost || isPeer) saveSession();
    });

    // =============================================
    // Reconnect Logic
    // =============================================

    function getReconnectDelay() {
      return Math.min(BASE_DELAY * Math.pow(2, reconnectAttempts), 30000);
    }

    function scheduleReconnect(role, roomId) {
      if (reconnectAttempts >= MAX_RECONNECT) {
        appendToTerminal(`[Remote] Max reconnect attempts reached. Click Share/Join to reconnect manually.\n`, 'error-msg');
        clearSession();
        return;
      }
      const delay = getReconnectDelay();
      reconnectAttempts++;
      appendToTerminal(`[Remote] Reconnecting in ${(delay / 1000).toFixed(0)}s (attempt ${reconnectAttempts}/${MAX_RECONNECT})...\n`, 'remote-msg');

      reconnectTimer = setTimeout(() => {
        if (role === 'host') {
          reconnectHost(roomId);
        } else {
          reconnectPeer(roomId);
        }
      }, delay);
    }

    function cancelReconnect() {
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      reconnectAttempts = 0;
    }

    function reconnectHost(roomId) {
      if (isHost) return; // already reconnected
      const peerId = 'serial-console-' + roomId;
      appendToTerminal(`[Remote] Re-establishing host session ${roomId}...\n`, 'remote-msg');

      // Destroy old peer if exists
      if (peer) { try { peer.destroy(); } catch {} }

      peer = new Peer(peerId, PEER_CONFIG);

      peer.on('open', () => {
        isHost = true;
        currentRoomId = roomId;
        reconnectAttempts = 0;
        document.getElementById('shareBtn').disabled = true;
        document.getElementById('roomIdDisplay').textContent = roomId;
        document.getElementById('roomIdContainer').style.display = 'inline';
        document.getElementById('allowInputLabel').style.display = 'inline-flex';
        document.getElementById('joinRoomInput').disabled = true;
        document.getElementById('joinBtn').disabled = true;
        appendToTerminal(`[Remote] Host session re-established. Room ID: ${roomId}\n`, 'remote-msg');
        saveSession();
      });

      peer.on('connection', handleIncomingConnection);

      peer.on('error', (err) => {
        appendToTerminal(`[Remote Error] ${err.message}\n`, 'error-msg');
        if (err.type === 'unavailable-id') {
          // ID taken — old session still registered, wait and retry
          appendToTerminal(`[Remote] Room ID still registered on signaling server. Retrying...\n`, 'remote-msg');
        }
        isHost = false;
        scheduleReconnect('host', roomId);
      });

      peer.on('disconnected', () => {
        if (isHost) {
          appendToTerminal(`[Remote] Lost connection to signaling server. Attempting to reconnect...\n`, 'error-msg');
          // PeerJS has built-in reconnect for signaling
          try { peer.reconnect(); } catch {
            isHost = false;
            scheduleReconnect('host', roomId);
          }
        }
      });
    }

    function reconnectPeer(roomId) {
      if (isPeer) return; // already reconnected
      const peerId = 'serial-console-' + roomId;
      appendToTerminal(`[Remote] Reconnecting to room ${roomId}...\n`, 'remote-msg');

      // Destroy old peer if exists
      if (peer) { try { peer.destroy(); } catch {} }

      peer = new Peer(PEER_CONFIG);

      peer.on('open', () => {
        peerConnection = peer.connect(peerId, { serialization: 'json' });

        const joinTimeout = setTimeout(() => {
          if (!isPeer) {
            appendToTerminal('[Remote] Reconnect attempt timed out.\n', 'error-msg');
            scheduleReconnect('peer', roomId);
          }
        }, 15000);

        setupPeerConnectionHandlers(peerConnection, roomId, joinTimeout);
      });

      peer.on('error', (err) => {
        appendToTerminal(`[Remote Error] ${err.message}\n`, 'error-msg');
        if (!isPeer) scheduleReconnect('peer', roomId);
      });
    }

    // Override appendToTerminal to also capture history and broadcast
    const _origAppend = appendToTerminal;
    appendToTerminal = function(text, className) {
      _origAppend(text, className);
      // Capture to history buffer (cap at 100KB)
      terminalHistory += text;
      if (terminalHistory.length > 100000) {
        terminalHistory = terminalHistory.slice(-80000);
      }
      // Host: broadcast to all connected peers
      if (isHost && hostConnections.length > 0) {
        const msg = { type: 'terminal', data: text, className: className || null };
        hostConnections.forEach(conn => {
          try { conn.send(msg); } catch (e) { console.error('[Remote] Send error:', e); }
        });
      }
    };

    function generateRoomId() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let id = '';
      for (let i = 0; i < 6; i++) id += chars[Math.floor(Math.random() * chars.length)];
      return id;
    }

    function updatePeerCountUI() {
      const countEl = document.getElementById('peerCount');
      const n = hostConnections.length;
      countEl.textContent = n + (n === 1 ? ' peer' : ' peers');
      countEl.style.display = n > 0 ? 'inline-flex' : 'none';
      // Also refresh the list if visible
      if (document.getElementById('peerListPanel').classList.contains('visible')) {
        renderPeerList();
      }
      if (n === 0) {
        document.getElementById('peerListPanel').classList.remove('visible');
      }
    }

    function togglePeerList() {
      const panel = document.getElementById('peerListPanel');
      panel.classList.toggle('visible');
      if (panel.classList.contains('visible')) renderPeerList();
    }

    // Close peer list when clicking outside
    document.addEventListener('click', (e) => {
      const panel = document.getElementById('peerListPanel');
      const badge = document.getElementById('peerCount');
      if (panel.classList.contains('visible') && !panel.contains(e.target) && e.target !== badge) {
        panel.classList.remove('visible');
      }
    });

    function formatDuration(ms) {
      const s = Math.floor(ms / 1000);
      if (s < 60) return s + 's';
      const m = Math.floor(s / 60);
      if (m < 60) return m + 'm ' + (s % 60) + 's';
      const h = Math.floor(m / 60);
      return h + 'h ' + (m % 60) + 'm';
    }

    function getPeerLabel(info) {
      return info.name || info.ip || info.id.replace('serial-console-', '').substring(0, 8);
    }

    function renderPeerList() {
      const body = document.getElementById('peerListBody');
      if (hostConnections.length === 0) {
        body.innerHTML = '<div class="peer-list-empty">No peers connected</div>';
        return;
      }
      const now = Date.now();
      body.innerHTML = hostConnections.map((conn, idx) => {
        const info = peerInfoMap.get(conn) || {};
        const displayName = info.name || '';
        const ip = info.ip || 'Resolving...';
        const duration = info.connectedAt ? formatDuration(now - info.connectedAt) : '—';
        const peerCanWrite = info.canWrite || false;
        const permClass = peerCanWrite ? 'rw' : 'ro';
        const permLabel = peerCanWrite ? 'R/W' : 'View';
        const nameHtml = displayName
          ? `<span style="color:var(--accent);font-weight:600;font-size:0.8rem;">${displayName}</span>`
          : '';
        return `<div class="peer-list-item">
          ${nameHtml}
          <span class="peer-ip">${ip}</span>
          <span class="peer-perm ${permClass}" style="cursor:pointer;" onclick="togglePeerWrite(${idx})" title="Click to toggle">${permLabel}</span>
          <span class="peer-duration">${duration}</span>
        </div>`;
      }).join('');
    }

    // Refresh durations every 10s while panel is open
    setInterval(() => {
      if (document.getElementById('peerListPanel').classList.contains('visible')) {
        renderPeerList();
      }
    }, 10000);

    // Extract remote IP from WebRTC stats
    async function extractRemoteIP(conn) {
      try {
        const pc = conn.peerConnection;
        if (!pc) return null;

        // Method 1: getStats() — look for succeeded candidate pairs
        const stats = await pc.getStats();
        for (const [, report] of stats) {
          if (report.type === 'candidate-pair' && report.state === 'succeeded') {
            // Find the remote candidate
            for (const [, r] of stats) {
              if (r.type === 'remote-candidate' && r.id === report.remoteCandidateId) {
                if (r.address || r.ip) return r.address || r.ip;
              }
            }
          }
        }

        // Method 2: Fall back to any remote candidate with a non-mDNS address
        for (const [, report] of stats) {
          if (report.type === 'remote-candidate') {
            const addr = report.address || report.ip;
            if (addr && !addr.endsWith('.local')) return addr;
          }
        }

        return null;
      } catch (e) {
        console.warn('[Peers] Failed to extract IP:', e);
        return null;
      }
    }

    // Poll for remote IP (it may not be available immediately)
    function startIPResolution(conn) {
      let attempts = 0;
      const interval = setInterval(async () => {
        attempts++;
        const ip = await extractRemoteIP(conn);
        if (ip) {
          const info = peerInfoMap.get(conn);
          if (info) {
            info.ip = ip;
            peerInfoMap.set(conn, info);
          }
          updatePeerCountUI();
          clearInterval(interval);
        } else if (attempts >= 10) {
          // After ~10s give up resolving
          const info = peerInfoMap.get(conn);
          if (info && !info.ip) {
            info.ip = 'Unknown';
            peerInfoMap.set(conn, info);
          }
          updatePeerCountUI();
          clearInterval(interval);
        }
      }, 1000);
    }

    // ---- HOST LOGIC ----

    function handleIncomingConnection(conn) {
      appendToTerminal(`[Remote] Incoming peer connection — awaiting approval...\n`, 'remote-msg');

      const pending = {
        conn: conn,
        id: conn.peer || 'unknown',
        name: null,
        ip: null,
        ready: false
      };

      const handlePendingOpen = () => {
        if (pending.ready) return;
        pending.ready = true;

        // Ask the peer to identify itself
        conn.send({ type: 'pending', message: 'Waiting for host approval...' });

        // Listen for identify before acceptance
        conn.on('data', (msg) => {
          try {
            const data = (typeof msg === 'string') ? JSON.parse(msg) : msg;
            if (data.type === 'identify' && data.name) {
              pending.name = data.name.substring(0, 20);
              renderPendingList();
            }
          } catch {}
        });

        // Try to resolve IP early
        resolveIPForPending(conn, pending);

        pendingConnections.push(pending);
        renderPendingList();
        appendToTerminal(`[Remote] Peer "${pending.name || pending.id}" is waiting for approval.\n`, 'remote-msg');
      };

      conn.on('open', handlePendingOpen);
      if (conn.open) handlePendingOpen();

      conn.on('close', () => {
        pendingConnections = pendingConnections.filter(p => p !== pending);
        renderPendingList();
      });

      conn.on('error', () => {
        pendingConnections = pendingConnections.filter(p => p !== pending);
        renderPendingList();
      });
    }

    async function resolveIPForPending(conn, pending) {
      for (let i = 0; i < 10; i++) {
        const ip = await extractRemoteIP(conn);
        if (ip) {
          pending.ip = ip;
          renderPendingList();
          return;
        }
        await new Promise(r => setTimeout(r, 1000));
      }
      pending.ip = 'Unknown';
      renderPendingList();
    }

    function renderPendingList() {
      const bar = document.getElementById('pendingBar');
      const list = document.getElementById('pendingList');

      if (pendingConnections.length === 0) {
        bar.classList.remove('has-pending');
        list.innerHTML = '';
        return;
      }

      bar.classList.add('has-pending');
      list.innerHTML = pendingConnections.map((p, idx) => {
        const name = p.name || '';
        const ip = p.ip || 'Resolving...';
        const nameHtml = name ? `<span class="pending-name">${name}</span>` : '';
        return `<div class="pending-request">
          <span style="color:#ffd700;">&#9888;</span>
          <span class="pending-info">
            ${nameHtml}
            <span class="pending-ip">${ip}</span>
            <span style="color:#8892b0;font-size:0.65rem;">wants to join</span>
          </span>
          <button class="accept-btn" onclick="acceptPeer(${idx})">Accept</button>
          <button class="reject-btn" onclick="rejectPeer(${idx})">Reject</button>
        </div>`;
      }).join('');
    }

    function acceptPeer(index) {
      const pending = pendingConnections[index];
      if (!pending) return;
      const conn = pending.conn;

      // Remove from pending
      pendingConnections.splice(index, 1);
      renderPendingList();

      // Promote to full connection
      if (hostConnections.includes(conn)) return;
      hostConnections.push(conn);

      const globalAllow = document.getElementById('allowRemoteInput').checked;
      peerInfoMap.set(conn, {
        id: pending.id,
        name: pending.name || null,
        ip: pending.ip || null,
        connectedAt: Date.now(),
        canWrite: globalAllow
      });

      // Continue IP resolution if not yet resolved
      if (!pending.ip || pending.ip === 'Unknown' || pending.ip === 'Resolving...') {
        startIPResolution(conn);
      }

      updatePeerCountUI();
      const label = pending.name || pending.ip || pending.id;
      appendToTerminal(`[Remote] ${label} accepted — peer connected (${hostConnections.length} total)\n`, 'remote-msg');

      // Send session data to the now-accepted peer
      conn.send({ type: 'accepted' });
      conn.send({ type: 'history', data: terminalHistory });
      conn.send({ type: 'status', connected: isConnected, info: portInfo.textContent });
      conn.send({ type: 'permission', canWrite: globalAllow });
      saveSession();

      // Replace the pending data listener with the real one
      // PeerJS uses EventEmitter — removeAllListeners is safe here
      try { conn.removeAllListeners('data'); } catch { try { conn.off('data'); } catch {} }
      conn.on('data', (msg) => {
        try {
          const data = (typeof msg === 'string') ? JSON.parse(msg) : msg;
          if (data.type === 'identify') {
            const info = peerInfoMap.get(conn);
            if (info && data.name) {
              info.name = data.name.substring(0, 20);
              updatePeerCountUI();
            }
          } else if (data.type === 'command') {
            const peerInfo = peerInfoMap.get(conn);
            if (peerInfo && peerInfo.canWrite) {
              if (isConnected && port && port.writable) {
                sendData(data.data);
                appendToTerminal(`${data.data}`, 'remote-msg');
              }
            }
          }
        } catch (e) {
          console.error('[Remote] Failed to parse peer data:', e);
        }
      });

      // Replace close/error handlers
      try { conn.removeAllListeners('close'); } catch { try { conn.off('close'); } catch {} }
      try { conn.removeAllListeners('error'); } catch { try { conn.off('error'); } catch {} }
      conn.on('close', () => {
        const info = peerInfoMap.get(conn);
        const closeLabel = info ? (info.name || info.ip || 'unknown') : '';
        peerInfoMap.delete(conn);
        hostConnections = hostConnections.filter(c => c !== conn);
        updatePeerCountUI();
        appendToTerminal(`[Remote] ${closeLabel ? closeLabel + ' ' : 'Peer '}disconnected (${hostConnections.length} remaining)\n`, 'remote-msg');
      });
      conn.on('error', (err) => {
        appendToTerminal(`[Remote Error] Host conn error: ${err}\n`, 'error-msg');
        peerInfoMap.delete(conn);
        hostConnections = hostConnections.filter(c => c !== conn);
        updatePeerCountUI();
      });
    }

    function rejectPeer(index) {
      const pending = pendingConnections[index];
      if (!pending) return;
      const conn = pending.conn;
      const label = pending.name || pending.ip || pending.id;

      // Notify peer they were rejected
      try { conn.send({ type: 'rejected', message: 'Connection rejected by host.' }); } catch {}

      // Close after a short delay so the message arrives
      setTimeout(() => {
        try { conn.close(); } catch {}
      }, 500);

      pendingConnections.splice(index, 1);
      renderPendingList();
      appendToTerminal(`[Remote] ${label} — connection rejected.\n`, 'remote-msg');
    }

    function startSharing() {
      if (isHost || isPeer) return;
      const roomId = generateRoomId();
      const peerId = 'serial-console-' + roomId;

      document.getElementById('shareBtn').disabled = true;
      appendToTerminal(`[Remote] Starting share session...\n`, 'remote-msg');

      peer = new Peer(peerId, PEER_CONFIG);

      peer.on('open', (id) => {
        isHost = true;
        currentRoomId = roomId;
        reconnectAttempts = 0;
        document.getElementById('roomIdDisplay').textContent = roomId;
        document.getElementById('roomIdContainer').style.display = 'inline';
        document.getElementById('allowInputLabel').style.display = 'inline-flex';
        document.getElementById('joinRoomInput').disabled = true;
        document.getElementById('joinBtn').disabled = true;
        appendToTerminal(`[Remote] Session shared. Room ID: ${roomId}\n`, 'remote-msg');
        saveSession();
      });

      peer.on('connection', handleIncomingConnection);

      peer.on('disconnected', () => {
        if (isHost && currentRoomId) {
          appendToTerminal(`[Remote] Lost signaling connection. Reconnecting...\n`, 'error-msg');
          try { peer.reconnect(); } catch {
            isHost = false;
            scheduleReconnect('host', currentRoomId);
          }
        }
      });

      peer.on('error', (err) => {
        appendToTerminal(`[Remote Error] ${err.message}\n`, 'error-msg');
        if (!isHost) {
          document.getElementById('shareBtn').disabled = false;
        } else if (currentRoomId) {
          isHost = false;
          scheduleReconnect('host', currentRoomId);
        }
      });
    }

    function stopSharing() {
      if (!isHost) return;
      cancelReconnect();
      // Close pending connections
      pendingConnections.forEach(p => {
        try { p.conn.close(); } catch {}
      });
      pendingConnections = [];
      renderPendingList();
      // Close accepted connections
      hostConnections.forEach(conn => {
        try { conn.close(); } catch {}
      });
      hostConnections = [];
      peerInfoMap.clear();
      if (peer) { peer.destroy(); peer = null; }
      isHost = false;
      currentRoomId = null;
      clearSession();

      document.getElementById('shareBtn').disabled = false;
      document.getElementById('roomIdContainer').style.display = 'none';
      document.getElementById('allowInputLabel').style.display = 'none';
      document.getElementById('peerCount').style.display = 'none';
      document.getElementById('joinRoomInput').disabled = false;
      document.getElementById('joinBtn').disabled = false;
      appendToTerminal('[Remote] Session sharing stopped.\n', 'remote-msg');
    }

    function copyRoomId() {
      const roomId = document.getElementById('roomIdDisplay').textContent;
      navigator.clipboard.writeText(roomId).then(() => {
        appendToTerminal(`[Remote] Room ID "${roomId}" copied to clipboard.\n`, 'remote-msg');
      });
    }

    function updatePeerPermissions() {
      const allowInput = document.getElementById('allowRemoteInput').checked;
      hostConnections.forEach(conn => {
        const info = peerInfoMap.get(conn);
        if (info) info.canWrite = allowInput;
        try { conn.send({ type: 'permission', canWrite: allowInput }); } catch {}
      });
      appendToTerminal(`[Remote] Remote input ${allowInput ? 'enabled' : 'disabled'} for all peers.\n`, 'remote-msg');
      if (document.getElementById('peerListPanel').classList.contains('visible')) renderPeerList();
    }

    // Toggle write permission for a single peer by index
    function togglePeerWrite(index) {
      const conn = hostConnections[index];
      if (!conn) return;
      const info = peerInfoMap.get(conn);
      if (!info) return;
      info.canWrite = !info.canWrite;
      try { conn.send({ type: 'permission', canWrite: info.canWrite }); } catch {}
      appendToTerminal(`[Remote] ${getPeerLabel(info)}: input ${info.canWrite ? 'enabled' : 'disabled'}.\n`, 'remote-msg');
      renderPeerList();
    }

    // ---- PEER LOGIC ----

    function setupPeerConnectionHandlers(conn, roomId, timeoutId) {
      let peerApproved = false;

      const handlePeerConnOpen = () => {
        if (isPeer || peerApproved) return;
        // Don't set isPeer yet — we're in "pending approval" state

        // Send identify immediately so host can see our name
        if (peerName) {
          conn.send({ type: 'identify', name: peerName });
        }

        appendToTerminal(`[Remote] Connected to host — waiting for approval...\n`, 'remote-msg');
        document.getElementById('peerStatus').style.display = 'inline-flex';
        document.getElementById('peerStatus').textContent = 'Waiting for approval...';
        document.getElementById('peerStatus').style.borderColor = '#ffd700';
        document.getElementById('peerStatus').style.color = '#ffd700';
        document.getElementById('peerStatus').style.background = '#3d2a0a';
        document.getElementById('shareBtn').disabled = true;
        document.getElementById('leaveBtn').style.display = '';
      };

      conn.on('open', handlePeerConnOpen);
      if (conn.open) handlePeerConnOpen();

      conn.on('data', (raw) => {
        try {
          const msg = (typeof raw === 'string') ? JSON.parse(raw) : raw;
          switch (msg.type) {
            case 'pending':
              // Host acknowledged, still waiting
              appendToTerminal(`[Remote] ${msg.message || 'Waiting for host approval...'}\n`, 'remote-msg');
              break;
            case 'accepted':
              // Host approved us!
              if (timeoutId) clearTimeout(timeoutId);
              peerApproved = true;
              isPeer = true;
              currentRoomId = roomId;
              reconnectAttempts = 0;

              document.getElementById('peerStatus').textContent = 'Connected to host';
              document.getElementById('peerStatus').style.borderColor = '';
              document.getElementById('peerStatus').style.color = '';
              document.getElementById('peerStatus').style.background = '';
              document.getElementById('permissionStatus').style.display = 'inline-flex';
              document.getElementById('joinRoomInput').disabled = true;

              document.body.classList.add('peer-mode');
              document.getElementById('connectBtn').style.display = 'none';

              appendToTerminal(`[Remote] Host accepted your connection!\n`, 'remote-msg');
              saveSession();
              break;
            case 'rejected':
              appendToTerminal(`[Remote] ${msg.message || 'Connection rejected by host.'}\n`, 'error-msg');
              // Clean up
              document.getElementById('peerStatus').style.display = 'none';
              document.getElementById('leaveBtn').style.display = 'none';
              document.getElementById('shareBtn').disabled = false;
              document.getElementById('joinBtn').disabled = false;
              document.getElementById('joinRoomInput').disabled = false;
              if (timeoutId) clearTimeout(timeoutId);
              break;
            case 'terminal':
              _origAppend(msg.data, msg.className);
              break;
            case 'history':
              terminal.innerHTML = '';
              _origAppend(msg.data);
              break;
            case 'status':
              if (msg.connected) {
                updateStatus(true, msg.info);
              }
              break;
            case 'permission':
              canWrite = msg.canWrite;
              sendInputEl.disabled = !canWrite;
              sendBtn.disabled = !canWrite;
              const badge = document.getElementById('permissionStatus');
              badge.textContent = canWrite ? 'Read/Write' : 'View Only';
              badge.className = 'permission-badge ' + (canWrite ? 'read-write' : 'view-only');
              sendInputEl.placeholder = canWrite ? 'Type command and press Enter...' : 'View only — host has not enabled remote input';
              break;
          }
        } catch {}
      });

      conn.on('close', () => {
        const wasConnected = isPeer;
        isPeer = false;
        peerApproved = false;
        canWrite = false;
        peerConnection = null;
        document.getElementById('peerStatus').style.display = 'none';
        document.getElementById('peerStatus').textContent = 'Connected to host';
        document.getElementById('peerStatus').style.borderColor = '';
        document.getElementById('peerStatus').style.color = '';
        document.getElementById('peerStatus').style.background = '';
        document.getElementById('permissionStatus').style.display = 'none';
        sendInputEl.disabled = true;
        sendBtn.disabled = true;
        appendToTerminal('[Remote] Disconnected from host.\n', 'error-msg');

        // Auto-reconnect if we were previously connected
        if (wasConnected && currentRoomId) {
          scheduleReconnect('peer', currentRoomId);
        } else {
          document.body.classList.remove('peer-mode');
          document.getElementById('shareBtn').disabled = false;
          document.getElementById('joinBtn').disabled = false;
          document.getElementById('joinRoomInput').disabled = false;
          document.getElementById('connectBtn').style.display = '';
          document.getElementById('leaveBtn').style.display = 'none';
        }
      });

      conn.on('error', (err) => {
        appendToTerminal(`[Remote Error] ${err.message}\n`, 'error-msg');
      });
    }

    function disconnectPeer() {
      cancelReconnect();
      isPeer = false;
      canWrite = false;
      currentRoomId = null;
      clearSession();
      if (peerConnection) { try { peerConnection.close(); } catch {} peerConnection = null; }
      if (peer) { try { peer.destroy(); } catch {} peer = null; }
      document.body.classList.remove('peer-mode');
      document.getElementById('peerStatus').style.display = 'none';
      document.getElementById('permissionStatus').style.display = 'none';
      document.getElementById('leaveBtn').style.display = 'none';
      document.getElementById('shareBtn').disabled = false;
      document.getElementById('joinBtn').disabled = false;
      document.getElementById('joinRoomInput').disabled = false;
      document.getElementById('connectBtn').style.display = '';
      sendInputEl.disabled = true;
      sendBtn.disabled = true;
      appendToTerminal('[Remote] Session left.\n', 'remote-msg');
    }

    function joinSession() {
      if (isHost || isPeer) return;
      const roomId = document.getElementById('joinRoomInput').value.trim().toUpperCase();
      if (!roomId || roomId.length !== 6) {
        appendToTerminal('[Remote] Please enter a valid 6-character Room ID.\n', 'error-msg');
        return;
      }

      // Capture friendly name
      peerName = document.getElementById('peerNameInput').value.trim().substring(0, 20);

      const peerId = 'serial-console-' + roomId;
      document.getElementById('joinBtn').disabled = true;
      appendToTerminal(`[Remote] Connecting to room ${roomId}...\n`, 'remote-msg');

      peer = new Peer(PEER_CONFIG);

      peer.on('open', () => {
        appendToTerminal(`[Remote] Signaling connected. Reaching out to host...\n`, 'remote-msg');
        peerConnection = peer.connect(peerId, { serialization: 'json' });

        const joinTimeout = setTimeout(() => {
          if (!isPeer) {
            appendToTerminal('[Remote] Connection timed out. Host may not be sharing.\n', 'error-msg');
            if (peerConnection) { try { peerConnection.close(); } catch {} }
            if (peer) { peer.destroy(); peer = null; }
            peerConnection = null;
            document.getElementById('joinBtn').disabled = false;
          }
        }, 15000);

        setupPeerConnectionHandlers(peerConnection, roomId, joinTimeout);
      });

      peer.on('error', (err) => {
        appendToTerminal(`[Remote Error] ${err.message}\n`, 'error-msg');
        if (!isPeer) {
          document.getElementById('joinBtn').disabled = false;
        }
      });
    }

    // Override sendData for peer mode — send via WebRTC instead of serial
    const _origSendData = sendData;
    sendData = async function(text) {
      if (isPeer && peerConnection && canWrite) {
        // Send command to host via WebRTC
        peerConnection.send({ type: 'command', data: text });
        if (document.getElementById('echoLocal').checked) {
          _origAppend(text, 'sent-msg');
        }
        return;
      }
      // Normal serial send
      return _origSendData(text);
    };

    // Handle room ID input — auto-uppercase and join on Enter
    document.getElementById('joinRoomInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        joinSession();
      }
    });
    document.getElementById('joinRoomInput').addEventListener('input', (e) => {
      e.target.value = e.target.value.toUpperCase();
    });

    // =============================================
    // Session Restore on Page Load
    // =============================================

    (function restoreSession() {
      const session = loadSession();

      if (!session || !session.roomId || !session.role) {
        // No session to restore — show normal welcome
        appendToTerminal('Serial Console — Web Serial API Terminal\n', 'system-msg');
        appendToTerminal('Click "Connect" to select a serial port, or use Remote to share/join.\n\n', 'system-msg');

        if (!('serial' in navigator)) {
          appendToTerminal('[Warning] Web Serial API is not available in this browser.\n', 'error-msg');
          appendToTerminal('You can still join a remote session using a Room ID.\n', 'system-msg');
          connectBtn.disabled = true;
        }
        return;
      }

      // Restore terminal history
      if (session.terminalHistory) {
        terminalHistory = session.terminalHistory;
        _origAppend(session.terminalHistory);
      }

      appendToTerminal(`\n[Session] Restoring ${session.role} session for room ${session.roomId}...\n`, 'system-msg');

      if (!('serial' in navigator)) {
        connectBtn.disabled = true;
      }

      if (session.role === 'host') {
        // Restore allow-input state
        if (session.allowInput) {
          document.getElementById('allowRemoteInput').checked = true;
        }
        reconnectHost(session.roomId);
      } else if (session.role === 'peer') {
        canWrite = session.allowInput || false;
        peerName = session.peerName || '';
        reconnectPeer(session.roomId);
      }
    })();
  </script>

</body>
</html>
